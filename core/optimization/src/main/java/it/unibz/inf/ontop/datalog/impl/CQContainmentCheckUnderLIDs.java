package it.unibz.inf.ontop.datalog.impl;

import java.util.*;

import com.google.common.collect.ImmutableList;
import it.unibz.inf.ontop.constraints.LinearInclusionDependencies;
import it.unibz.inf.ontop.datalog.*;
import it.unibz.inf.ontop.model.atom.AtomFactory;
import it.unibz.inf.ontop.model.atom.AtomPredicate;
import it.unibz.inf.ontop.model.atom.DataAtom;
import it.unibz.inf.ontop.model.term.*;
import it.unibz.inf.ontop.model.term.functionsymbol.Predicate;
import it.unibz.inf.ontop.model.term.impl.ImmutabilityTools;
import it.unibz.inf.ontop.substitution.Substitution;
import it.unibz.inf.ontop.substitution.SubstitutionBuilder;
import it.unibz.inf.ontop.utils.ImmutableCollectors;

public class CQContainmentCheckUnderLIDs {

	private final Map<AbstractMap.SimpleEntry<Function, List<Function>>, IndexedCQ> indexedCQcache = new HashMap<>();
	
	private final LinearInclusionDependencies<AtomPredicate> dependencies;
	private final AtomFactory atomFactory;
	private final TermFactory termFactory;
	private final ImmutabilityTools immutabilityTools;

	/**
	 * *@param sigma
	 * A set of ABox dependencies
	 */
	public CQContainmentCheckUnderLIDs(LinearInclusionDependencies<AtomPredicate> dependencies,
									   AtomFactory atomFactory, TermFactory termFactory, ImmutabilityTools immutabilityTools) {
	    // index dependencies
		this.dependencies = dependencies;
		this.atomFactory = atomFactory;
		this.termFactory = termFactory;
		this.immutabilityTools = immutabilityTools;
	}





	public final class IndexedCQ {
		
		private final Function head;
		/***
		 * An index of all the facts obtained by freezing this query.
		 */
		private final Map<Predicate, List<Function>> factMap;

		/***
		 * Computes a query in which all terms have been replaced by
		 * ValueConstants that have the no type and have the same 'name' as the
		 * original variable.
		 * 
		 * This new query can be used for query containment checking.
		 * 
		 */
		
		public IndexedCQ(Function head, Collection<Function> body) { 
			
			this.head = head;

			this.factMap = new HashMap<>(body.size() * 2);
			for (Function atom : body) 
				// not boolean, not algebra, not arithmetic, not datatype
				if (atom != null && atom.isDataFunction()) {
					Predicate pred = atom.getFunctionSymbol();
					List<Function> facts = factMap.get(pred);
					if (facts == null) {
						facts = new LinkedList<>();
						factMap.put(pred, facts);
					}
					facts.add(atom);
				}
		}
		
		private Substitution computeHomomorphism(Function head, List<Function> body) {
			SubstitutionBuilder sb = new  SubstitutionBuilder(termFactory);

			// get the substitution for the head first 
			// it will ensure that all answer variables are mapped either to constants or
			//       to answer variables in the base (but not to the labelled nulls generated by the chase)
			boolean headResult = extendHomomorphism(sb, head, this.head);
			if (!headResult)
				return null;
			
			Substitution sub = computeSomeHomomorphism(sb, body, factMap);
			
			return sub;
		}	
	}



	public Substitution computeHomomorphsim(Function h1, List<Function> b1, Function h2, List<Function> b2) {

		AbstractMap.SimpleEntry<Function, List<Function>> q1 = new AbstractMap.SimpleEntry(h1, b1);
        IndexedCQ indexedQ1 = indexedCQcache.get(q1);
        if (indexedQ1 == null) {
			ImmutableList<DataAtom<AtomPredicate>> matoms = b1.stream()
					.map(a -> atomFactory.getDataAtom((AtomPredicate)a.getFunctionSymbol(),
							a.getTerms().stream()
									.map(t -> (VariableOrGroundTerm)immutabilityTools.convertIntoImmutableTerm(t))
									.collect(ImmutableCollectors.toList())))
					.collect(ImmutableCollectors.toList());

			Collection<Function> q1body = dependencies.chaseAllAtoms(matoms).stream()
					.map(immutabilityTools::convertToMutableFunction)
					.collect(ImmutableCollectors.toSet());

        	indexedQ1 = new IndexedCQ(h1, q1body);
    		indexedCQcache.put(q1, indexedQ1);
        }
           
        // just to speed up the check in case there can be no match
        for (Function q2atom : b2)
			if (!indexedQ1.factMap.containsKey(q2atom.getFunctionSymbol())) {
				// in particular, !q2atom.isDataFunction() 
				return null;
			}
				
		return indexedQ1.computeHomomorphism(h2, b2);
	}	

	public CQIE removeRedundantAtoms(CQIE query) {
		List<Function> databaseAtoms = new ArrayList<>(query.getBody().size());
		
		Set<Term> groundTerms = new HashSet<>();
		for (Function atom : query.getBody())
			// non-database atom
			if (!(atom.getFunctionSymbol() instanceof AtomPredicate)) {
				collectVariables(groundTerms, atom);
			}
			else {
				databaseAtoms.add(atom);
			}

		if (databaseAtoms.size() < 2) {
			return query;
		}
		
		collectVariables(groundTerms, query.getHead());
		
		for (int i = 0; i < databaseAtoms.size(); i++) {
			Function atomToBeRemoved = databaseAtoms.get(i);
			if (checkRedundant(query.getHead(), databaseAtoms, groundTerms, atomToBeRemoved)) {
				query.getBody().remove(atomToBeRemoved);
				databaseAtoms.remove(atomToBeRemoved);
				i--;
			}
		}
		
		return query;
	}
	
	private boolean checkRedundant(Function head, List<Function> body, Set<Term> groundTerms, Function atomToBeRemoved) {
		List<Function> atomsToLeave = new ArrayList<>(body.size() - 1);
		Set<Term> variablesInAtomsToLeave = new HashSet<>();
		for (Function a: body)
			if (a != atomToBeRemoved) {
				atomsToLeave.add(a);
				collectVariables(variablesInAtomsToLeave, a);
			}
		
		if (!variablesInAtomsToLeave.containsAll(groundTerms)) {
			return false;
		}

		// if db is homomorphically embeddable into q0
		if (computeHomomorphsim(head, atomsToLeave, head, body) != null) {
			return true;
		}
		return false;
	}


	private static void collectVariables(Set<Term> vars, Function atom) {
		Deque<Term> terms = new LinkedList<>(atom.getTerms());
		while (!terms.isEmpty()) {
			Term t = terms.pollFirst();
			if (t instanceof Variable)
				vars.add(t);
			else if (!(t instanceof Constant))
				terms.addAll(((Function)t).getTerms());
		}		
	}

	@Override
	public String toString() {
		if (dependencies != null)
			return dependencies.toString();
		
		return "(empty)";
	}



	private static boolean extendHomomorphism(SubstitutionBuilder sb, Function from, Function to) {

		if ((from.getArity() != to.getArity()) || !(from.getFunctionSymbol().equals(to.getFunctionSymbol())))
			return false;

		int arity = from.getArity();
		for (int i = 0; i < arity; i++) {
			Term fromTerm = from.getTerm(i);
			Term toTerm = to.getTerm(i);
			if (fromTerm instanceof Variable) {
				boolean result = sb.extend((Variable)fromTerm, toTerm);
				// if we cannot find a match, terminate the process and return false
				if (!result)
					return false;
			}
			else if (fromTerm instanceof Constant) {
				// constants must match
				if (!fromTerm.equals(toTerm))
					return false;
			}
			else /*if (fromTerm instanceof Function)*/ {
				// the to term must also be a function
				if (!(toTerm instanceof Function))
					return false;

				boolean result = extendHomomorphism(sb, (Function)fromTerm, (Function)toTerm);
				// if we cannot find a match, terminate the process and return false
				if (!result)
					return false;
			}
		}

		return true;
	}

	/**
	 * Extends a given substitution that maps each atom in {@code from} to match at least one atom in {@code to}
	 *
	 * @param sb
	 * @param from
	 * @param to
	 * @return
	 */
	private static Substitution computeSomeHomomorphism(SubstitutionBuilder sb, List<Function> from, Map<Predicate, List<Function>> to) {

		int fromSize = from.size();
		if (fromSize == 0)
			return sb.getSubstituition();

		// stack of partial homomorphisms
		Stack<SubstitutionBuilder> sbStack = new Stack<>();
		sbStack.push(sb);
		// set the capacity to reduce memory re-allocations
		List<Stack<Function>> choicesMap = new ArrayList<>(fromSize);

		int currentAtomIdx = 0;
		while (currentAtomIdx >= 0) {
			Function currentAtom = from.get(currentAtomIdx);

			Stack<Function> choices;
			if (currentAtomIdx >= choicesMap.size()) {
				// we have never reached this atom (this is lazy initialization)
				// initializing the stack
				choices = new Stack<>();
				// add all choices for the current predicate symbol
				choices.addAll(to.get(currentAtom.getFunctionSymbol()));
				choicesMap.add(currentAtomIdx, choices);
			}
			else
				choices = choicesMap.get(currentAtomIdx);

			boolean choiceMade = false;
			while (!choices.isEmpty()) {
				SubstitutionBuilder sb1 = sb.clone(); // clone!
				choiceMade = extendHomomorphism(sb1, currentAtom, choices.pop());
				if (choiceMade) {
					// we reached the last atom
					if (currentAtomIdx == fromSize - 1)
						return sb1.getSubstituition();

					// otherwise, save the partial homomorphism
					sbStack.push(sb);
					sb = sb1;
					currentAtomIdx++;  // move to the next atom
					break;
				}
			}
			if (!choiceMade) {
				// backtracking
				// restore all choices for the current predicate symbol
				choices.addAll(to.get(currentAtom.getFunctionSymbol()));
				sb = sbStack.pop();   // restore the partial homomorphism
				currentAtomIdx--;   // move to the previous atom
			}
		}

		// checked all possible substitutions and have not found anything
		return null;
	}

}
