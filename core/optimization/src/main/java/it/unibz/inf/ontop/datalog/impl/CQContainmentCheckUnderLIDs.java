package it.unibz.inf.ontop.datalog.impl;

import java.util.*;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Multimap;
import it.unibz.inf.ontop.constraints.LinearInclusionDependencies;
import it.unibz.inf.ontop.datalog.*;
import it.unibz.inf.ontop.model.atom.AtomFactory;
import it.unibz.inf.ontop.model.atom.AtomPredicate;
import it.unibz.inf.ontop.model.atom.DataAtom;
import it.unibz.inf.ontop.model.term.*;
import it.unibz.inf.ontop.model.term.functionsymbol.Predicate;
import it.unibz.inf.ontop.model.term.impl.ImmutabilityTools;
import it.unibz.inf.ontop.substitution.Substitution;
import it.unibz.inf.ontop.substitution.SubstitutionBuilder;
import it.unibz.inf.ontop.utils.ImmutableCollectors;

public class CQContainmentCheckUnderLIDs {

	private final Map<ImmutableList<DataAtom<AtomPredicate>>, Multimap<Predicate, Function>> indexedCQcache = new HashMap<>();
	
	private final LinearInclusionDependencies<AtomPredicate> dependencies;
	private final AtomFactory atomFactory;
	private final TermFactory termFactory;
	private final ImmutabilityTools immutabilityTools;

	/**
	 * *@param sigma
	 * A set of ABox dependencies
	 */
	public CQContainmentCheckUnderLIDs(LinearInclusionDependencies<AtomPredicate> dependencies,
									   AtomFactory atomFactory, TermFactory termFactory, ImmutabilityTools immutabilityTools) {
	    // index dependencies
		this.dependencies = dependencies;
		this.atomFactory = atomFactory;
		this.termFactory = termFactory;
		this.immutabilityTools = immutabilityTools;
	}

	private ImmutableList<DataAtom<AtomPredicate>> toI(List<Function> body) {
		return body.stream()
				.map(a -> atomFactory.getDataAtom((AtomPredicate)a.getFunctionSymbol(),
						a.getTerms().stream()
								.map(t -> (VariableOrGroundTerm)immutabilityTools.convertIntoImmutableTerm(t))
								.collect(ImmutableCollectors.toList())))
				.collect(ImmutableCollectors.toList());
	}

	private ImmutableList<Function> fromI(ImmutableCollection<DataAtom<AtomPredicate>> c) {
		return c.stream()
				.map(immutabilityTools::convertToMutableFunction)
				.collect(ImmutableCollectors.toList());
	}

	private Multimap<Predicate, Function> getFactMap(ImmutableList<DataAtom<AtomPredicate>> body) {
		Multimap<Predicate, Function> factMap = indexedCQcache.get(body);
		if (factMap == null) {
			factMap = HashMultimap.create();
			for (Function atom : fromI(dependencies.chaseAllAtoms(body)))
				factMap.put(atom.getFunctionSymbol(), atom);

			indexedCQcache.put(body, factMap);
		}
		return factMap;
	}

	public Substitution computeHomomorphsim(Function h1, ImmutableList<DataAtom<AtomPredicate>> b1, Function h2, ImmutableList<DataAtom<AtomPredicate>> b2) {

		SubstitutionBuilder sb = new SubstitutionBuilder(termFactory);

		// get the substitution for the head first
		// it will ensure that all answer variables are mapped either to constants or
		//       to answer variables in the base (but not to the labelled nulls generated by the chase)
		boolean headResult = extendHomomorphism(sb, h2, h1);
		if (!headResult)
			return null;

		Substitution sub = computeSomeHomomorphism(sb, fromI(b2), getFactMap(b1));

		return sub;
	}


	public CQIE removeRedundantAtoms(CQIE query) {
		List<Function> databaseAtoms = new ArrayList<>(query.getBody().size());
		
		Set<Term> groundTerms = new HashSet<>();
		for (Function atom : query.getBody())
			// non-database atom
			if (!(atom.getFunctionSymbol() instanceof AtomPredicate)) {
				collectVariables(groundTerms, atom);
			}
			else {
				databaseAtoms.add(atom);
			}

		if (databaseAtoms.size() < 2) {
			return query;
		}
		
		collectVariables(groundTerms, query.getHead());
		
		for (int i = 0; i < databaseAtoms.size(); i++) {
			Function atomToBeRemoved = databaseAtoms.get(i);

			List<Function> atomsToLeave = new ArrayList<>(databaseAtoms.size() - 1);
			Set<Term> variablesInAtomsToLeave = new HashSet<>();
			for (Function a: databaseAtoms)
				if (a != atomToBeRemoved) {
					atomsToLeave.add(a);
					collectVariables(variablesInAtomsToLeave, a);
				}

			if (!variablesInAtomsToLeave.containsAll(groundTerms))
				continue;

			SubstitutionBuilder sb = new SubstitutionBuilder(termFactory);
			Substitution sub = computeSomeHomomorphism(sb, databaseAtoms, getFactMap(toI(atomsToLeave)));
			if (sub != null) {
				query.getBody().remove(atomToBeRemoved);
				databaseAtoms.remove(atomToBeRemoved);
				i--;
			}
		}
		
		return query;
	}
	
	private static void collectVariables(Set<Term> vars, Function atom) {
		Deque<Term> terms = new LinkedList<>(atom.getTerms());
		while (!terms.isEmpty()) {
			Term t = terms.pollFirst();
			if (t instanceof Variable)
				vars.add(t);
			else if (!(t instanceof Constant))
				terms.addAll(((Function)t).getTerms());
		}		
	}

	@Override
	public String toString() {
		if (dependencies != null)
			return dependencies.toString();
		
		return "(empty)";
	}



	private static boolean extendHomomorphism(SubstitutionBuilder sb, Function from, Function to) {

		if ((from.getArity() != to.getArity()) || !(from.getFunctionSymbol().equals(to.getFunctionSymbol())))
			return false;

		int arity = from.getArity();
		for (int i = 0; i < arity; i++) {
			Term fromTerm = from.getTerm(i);
			Term toTerm = to.getTerm(i);
			if (fromTerm instanceof Variable) {
				boolean result = sb.extend((Variable)fromTerm, toTerm);
				// if we cannot find a match, terminate the process and return false
				if (!result)
					return false;
			}
			else if (fromTerm instanceof Constant) {
				// constants must match
				if (!fromTerm.equals(toTerm))
					return false;
			}
			else /*if (fromTerm instanceof Function)*/ {
				// the to term must also be a function
				if (!(toTerm instanceof Function))
					return false;

				boolean result = extendHomomorphism(sb, (Function)fromTerm, (Function)toTerm);
				// if we cannot find a match, terminate the process and return false
				if (!result)
					return false;
			}
		}

		return true;
	}

	/**
	 * Extends a given substitution that maps each atom in {@code from} to match at least one atom in {@code to}
	 *
	 * @param sb
	 * @param from
	 * @param to
	 * @return
	 */
	private static Substitution computeSomeHomomorphism(SubstitutionBuilder sb, List<Function> from, Multimap<Predicate, Function> to) {

		int fromSize = from.size();
		if (fromSize == 0)
			return sb.getSubstituition();

		// stack of partial homomorphisms
		Stack<SubstitutionBuilder> sbStack = new Stack<>();
		sbStack.push(sb);
		// set the capacity to reduce memory re-allocations
		List<Stack<Function>> choicesMap = new ArrayList<>(fromSize);

		int currentAtomIdx = 0;
		while (currentAtomIdx >= 0) {
			Function currentAtom = from.get(currentAtomIdx);

			Stack<Function> choices;
			if (currentAtomIdx >= choicesMap.size()) {
				// we have never reached this atom (this is lazy initialization)
				// initializing the stack
				choices = new Stack<>();
				// add all choices for the current predicate symbol
				choices.addAll(to.get(currentAtom.getFunctionSymbol()));
				choicesMap.add(currentAtomIdx, choices);
			}
			else
				choices = choicesMap.get(currentAtomIdx);

			boolean choiceMade = false;
			while (!choices.isEmpty()) {
				SubstitutionBuilder sb1 = sb.clone(); // clone!
				choiceMade = extendHomomorphism(sb1, currentAtom, choices.pop());
				if (choiceMade) {
					// we reached the last atom
					if (currentAtomIdx == fromSize - 1)
						return sb1.getSubstituition();

					// otherwise, save the partial homomorphism
					sbStack.push(sb);
					sb = sb1;
					currentAtomIdx++;  // move to the next atom
					break;
				}
			}
			if (!choiceMade) {
				// backtracking
				// restore all choices for the current predicate symbol
				choices.addAll(to.get(currentAtom.getFunctionSymbol()));
				sb = sbStack.pop();   // restore the partial homomorphism
				currentAtomIdx--;   // move to the previous atom
			}
		}

		// checked all possible substitutions and have not found anything
		return null;
	}

}
