package it.unibz.inf.ontop.datalog.impl;

import java.util.*;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMultimap;
import it.unibz.inf.ontop.datalog.*;
import it.unibz.inf.ontop.model.atom.AtomPredicate;
import it.unibz.inf.ontop.model.term.*;
import it.unibz.inf.ontop.model.term.functionsymbol.Predicate;
import it.unibz.inf.ontop.substitution.Substitution;
import it.unibz.inf.ontop.substitution.SubstitutionBuilder;
import it.unibz.inf.ontop.substitution.impl.SubstitutionUtilities;
import it.unibz.inf.ontop.substitution.impl.UnifierUtilities;
import it.unibz.inf.ontop.utils.ImmutableCollectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CQContainmentCheckUnderLIDs {

	private static final Logger LOGGER = LoggerFactory.getLogger(CQContainmentCheckUnderLIDs.class);
	
	private final Map<CQIE,IndexedCQ> indexedCQcache = new HashMap<>();
	
	private final ImmutableMultimap<Predicate, LinearInclusionDependency> dependencies;
	private final DatalogFactory datalogFactory;
	private final UnifierUtilities unifierUtilities;
	private final SubstitutionUtilities substitutionUtilities;
	private final TermFactory termFactory;

	/**
	 * *@param sigma
	 * A set of ABox dependencies
	 */
	public CQContainmentCheckUnderLIDs(ImmutableList<LinearInclusionDependency> dependencies, DatalogFactory datalogFactory,
                                       UnifierUtilities unifierUtilities, SubstitutionUtilities substitutionUtilities,
                                       TermFactory termFactory) {
	    // index dependencies
		this.dependencies = dependencies.stream()
				.collect(ImmutableCollectors.toMultimap(
						d -> d.getHead().getFunctionSymbol(),
						d -> d));
		this.datalogFactory = datalogFactory;
		this.unifierUtilities = unifierUtilities;
		this.substitutionUtilities = substitutionUtilities;
		this.termFactory = termFactory;
	}



    /**
	 * This method is used to chase foreign key constraint rule in which the rule
	 * has only one atom in the body.
	 * 
	 * IMPORTANT: each rule is applied only ONCE to each atom
	 * 
	 * @param atoms
	 * @return set of atoms
	 */
	private Set<Function> chaseAtoms(Collection<Function> atoms) {

		Set<Function> derivedAtoms = new HashSet<>();
		for (Function fact : atoms) {
			derivedAtoms.add(fact);
			for (LinearInclusionDependency d : dependencies.get(fact.getFunctionSymbol())) {
				CQIE rule = datalogFactory.getFreshCQIECopy(datalogFactory.getCQIE(d.getHead(), d.getBody()));
				Function ruleBody = rule.getBody().get(0);
				Substitution theta = unifierUtilities.getMGU(ruleBody, fact);
				if (theta != null && !theta.isEmpty()) {
					Function ruleHead = rule.getHead();
					Function newFact = (Function)ruleHead.clone();
					// unify to get fact is needed because the dependencies are not necessarily full
					// (in other words, they may contain existentials in the head)
					substitutionUtilities.applySubstitution(newFact, theta);
					derivedAtoms.add(newFact);
				}
			}
		}
		return derivedAtoms;
	}
	
	public final class IndexedCQ {
		
		private final Function head;
		/***
		 * An index of all the facts obtained by freezing this query.
		 */
		private final Map<Predicate, List<Function>> factMap;

		/***
		 * Computes a query in which all terms have been replaced by
		 * ValueConstants that have the no type and have the same 'name' as the
		 * original variable.
		 * 
		 * This new query can be used for query containment checking.
		 * 
		 */
		
		public IndexedCQ(Function head, Collection<Function> body) { 
			
			this.head = head;

			this.factMap = new HashMap<>(body.size() * 2);
			for (Function atom : body) 
				// not boolean, not algebra, not arithmetic, not datatype
				if (atom != null && atom.isDataFunction()) {
					Predicate pred = atom.getFunctionSymbol();
					List<Function> facts = factMap.get(pred);
					if (facts == null) {
						facts = new LinkedList<Function>();
						factMap.put(pred, facts);
					}
					facts.add(atom);
				}
		}
		
		private Substitution computeHomomorphism(CQIE query) {
			SubstitutionBuilder sb = new  SubstitutionBuilder(termFactory);

			// get the substitution for the head first 
			// it will ensure that all answer variables are mapped either to constants or
			//       to answer variables in the base (but not to the labelled nulls generated by the chase)
			boolean headResult = extendHomomorphism(sb, query.getHead(), head);
			if (!headResult)
				return null;
			
			Substitution sub = computeSomeHomomorphism(sb, query.getBody(), factMap);
			
			return sub;
		}	
	}

	

	public Substitution computeHomomorphsim(CQIE q1, CQIE q2) {

        IndexedCQ indexedQ1 = indexedCQcache.get(q1);
        if (indexedQ1 == null) {
        	Collection<Function> q1body = q1.getBody();
        	if (dependencies != null)
        		q1body = chaseAtoms(q1body);
        	
        	indexedQ1 = new IndexedCQ(q1.getHead(), q1body);
    		indexedCQcache.put(q1, indexedQ1);
        }
           
        // just to speed up the check in case there can be no match
        for (Function q2atom : q2.getBody()) 
			if (!indexedQ1.factMap.containsKey(q2atom.getFunctionSymbol())) { 
				// in particular, !q2atom.isDataFunction() 
				return null;
			}
				
		return indexedQ1.computeHomomorphism(q2);
	}	

	static int redundantCounter = 0;
	public static int twoAtomQs = 0;
	public static int oneAtomQs = 0;
	
	public CQIE removeRedundantAtoms(CQIE query) {
		List<Function> databaseAtoms = new ArrayList<>(query.getBody().size());
		
		Set<Term> groundTerms = new HashSet<>();
		for (Function atom : query.getBody())
			// non-database atom
			if (!(atom.getFunctionSymbol() instanceof AtomPredicate)) {
				collectVariables(groundTerms, atom);
			}
			else {
				databaseAtoms.add(atom);
			}

		if (databaseAtoms.size() < 2) {
			oneAtomQs++;
			return query;
		}
		
		collectVariables(groundTerms, query.getHead());
		
		CQIE db = datalogFactory.getCQIE(query.getHead(), databaseAtoms);
		
		for (int i = 0; i < databaseAtoms.size(); i++) {
			Function atomToBeRemoved = databaseAtoms.get(i);
			if (checkRedundant(db, groundTerms, atomToBeRemoved)) {
				LOGGER.warn("  REDUNDANT " + ++redundantCounter + ": " + atomToBeRemoved + " IN " + query);
				query.getBody().remove(atomToBeRemoved);
				databaseAtoms.remove(atomToBeRemoved);
				i--;
			}
		}
		
		twoAtomQs++;
		return query;
	}
	
	private boolean checkRedundant(CQIE db, Set<Term> groundTerms, Function atomToBeRemoved) {
		List<Function> atomsToLeave = new ArrayList<>(db.getBody().size() - 1);
		Set<Term> variablesInAtomsToLeave = new HashSet<>();
		for (Function a: db.getBody()) 
			if (a != atomToBeRemoved) {
				atomsToLeave.add(a);
				collectVariables(variablesInAtomsToLeave, a);
			}
		
		if (!variablesInAtomsToLeave.containsAll(groundTerms)) {
			return false;
		}

		CQIE q0 = datalogFactory.getCQIE(db.getHead(), atomsToLeave);
		// if db is homomorphically embeddable into q0
		if (computeHomomorphsim(q0, db) != null) {
			oneAtomQs++;
			return true;
		}
		return false;
	}


	private static void collectVariables(Set<Term> vars, Function atom) {
		Deque<Term> terms = new LinkedList<>(atom.getTerms());
		while (!terms.isEmpty()) {
			Term t = terms.pollFirst();
			if (t instanceof Variable)
				vars.add(t);
			else if (!(t instanceof Constant))
				terms.addAll(((Function)t).getTerms());
		}		
	}

	@Override
	public String toString() {
		if (dependencies != null)
			return dependencies.toString();
		
		return "(empty)";
	}

	public ImmutableMultimap<Predicate, LinearInclusionDependency> dependencies() { return dependencies; }




	private static boolean extendHomomorphism(SubstitutionBuilder sb, Function from, Function to) {

		if ((from.getArity() != to.getArity()) || !(from.getFunctionSymbol().equals(to.getFunctionSymbol())))
			return false;

		int arity = from.getArity();
		for (int i = 0; i < arity; i++) {
			Term fromTerm = from.getTerm(i);
			Term toTerm = to.getTerm(i);
			if (fromTerm instanceof Variable) {
				boolean result = sb.extend((Variable)fromTerm, toTerm);
				// if we cannot find a match, terminate the process and return false
				if (!result)
					return false;
			}
			else if (fromTerm instanceof Constant) {
				// constants must match
				if (!fromTerm.equals(toTerm))
					return false;
			}
			else /*if (fromTerm instanceof Function)*/ {
				// the to term must also be a function
				if (!(toTerm instanceof Function))
					return false;

				boolean result = extendHomomorphism(sb, (Function)fromTerm, (Function)toTerm);
				// if we cannot find a match, terminate the process and return false
				if (!result)
					return false;
			}
		}

		return true;
	}

	/**
	 * Extends a given substitution that maps each atom in {@code from} to match at least one atom in {@code to}
	 *
	 * @param sb
	 * @param from
	 * @param to
	 * @return
	 */
	private static Substitution computeSomeHomomorphism(SubstitutionBuilder sb, List<Function> from, Map<Predicate, List<Function>> to) {

		int fromSize = from.size();
		if (fromSize == 0)
			return sb.getSubstituition();

		// stack of partial homomorphisms
		Stack<SubstitutionBuilder> sbStack = new Stack<>();
		sbStack.push(sb);
		// set the capacity to reduce memory re-allocations
		List<Stack<Function>> choicesMap = new ArrayList<>(fromSize);

		int currentAtomIdx = 0;
		while (currentAtomIdx >= 0) {
			Function currentAtom = from.get(currentAtomIdx);

			Stack<Function> choices;
			if (currentAtomIdx >= choicesMap.size()) {
				// we have never reached this atom (this is lazy initialization)
				// initializing the stack
				choices = new Stack<>();
				// add all choices for the current predicate symbol
				choices.addAll(to.get(currentAtom.getFunctionSymbol()));
				choicesMap.add(currentAtomIdx, choices);
			}
			else
				choices = choicesMap.get(currentAtomIdx);

			boolean choiceMade = false;
			while (!choices.isEmpty()) {
				SubstitutionBuilder sb1 = sb.clone(); // clone!
				choiceMade = extendHomomorphism(sb1, currentAtom, choices.pop());
				if (choiceMade) {
					// we reached the last atom
					if (currentAtomIdx == fromSize - 1)
						return sb1.getSubstituition();

					// otherwise, save the partial homomorphism
					sbStack.push(sb);
					sb = sb1;
					currentAtomIdx++;  // move to the next atom
					break;
				}
			}
			if (!choiceMade) {
				// backtracking
				// restore all choices for the current predicate symbol
				choices.addAll(to.get(currentAtom.getFunctionSymbol()));
				sb = sbStack.pop();   // restore the partial homomorphism
				currentAtomIdx--;   // move to the previous atom
			}
		}

		// checked all possible substitutions and have not found anything
		return null;
	}

}
