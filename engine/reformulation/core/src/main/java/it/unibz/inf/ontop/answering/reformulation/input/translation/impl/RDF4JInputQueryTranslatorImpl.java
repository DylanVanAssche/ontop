package it.unibz.inf.ontop.answering.reformulation.input.translation.impl;

import com.google.common.collect.*;
import com.google.inject.Inject;
import it.unibz.inf.ontop.answering.reformulation.input.translation.RDF4JInputQueryTranslator;
import it.unibz.inf.ontop.exception.OntopInternalBugException;
import it.unibz.inf.ontop.exception.OntopInvalidInputQueryException;
import it.unibz.inf.ontop.exception.OntopUnsupportedInputQueryException;
import it.unibz.inf.ontop.injection.IntermediateQueryFactory;
import it.unibz.inf.ontop.iq.IQ;
import it.unibz.inf.ontop.iq.IQTree;
import it.unibz.inf.ontop.iq.UnaryIQTree;
import it.unibz.inf.ontop.iq.node.*;
import it.unibz.inf.ontop.model.atom.AtomFactory;
import it.unibz.inf.ontop.model.term.*;
import it.unibz.inf.ontop.model.term.functionsymbol.FunctionSymbolFactory;
import it.unibz.inf.ontop.model.term.functionsymbol.LangSPARQLFunctionSymbol;
import it.unibz.inf.ontop.model.term.functionsymbol.SPARQLFunctionSymbol;
import it.unibz.inf.ontop.model.term.impl.ImmutabilityTools;
import it.unibz.inf.ontop.model.type.RDFDatatype;
import it.unibz.inf.ontop.model.type.TermTypeInference;
import it.unibz.inf.ontop.model.type.TypeFactory;
import it.unibz.inf.ontop.model.vocabulary.SPARQL;
import it.unibz.inf.ontop.model.vocabulary.XPathFunction;
import it.unibz.inf.ontop.model.vocabulary.XSD;
import it.unibz.inf.ontop.substitution.ImmutableSubstitution;
import it.unibz.inf.ontop.substitution.InjectiveVar2VarSubstitution;
import it.unibz.inf.ontop.substitution.SubstitutionFactory;
import it.unibz.inf.ontop.utils.CoreUtilsFactory;
import it.unibz.inf.ontop.utils.ImmutableCollectors;
import it.unibz.inf.ontop.utils.R2RMLIRISafeEncoder;
import it.unibz.inf.ontop.utils.VariableGenerator;
import org.apache.commons.rdf.api.RDF;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Literal;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.datatypes.XMLDatatypeUtil;
import org.eclipse.rdf4j.query.Binding;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.algebra.*;
import org.eclipse.rdf4j.query.parser.ParsedQuery;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class RDF4JInputQueryTranslatorImpl implements RDF4JInputQueryTranslator {

    private final CoreUtilsFactory coreUtilsFactory;
    private final TermFactory termFactory;
    private final SubstitutionFactory substitutionFactory;
    private final TypeFactory typeFactory;
    private final IntermediateQueryFactory iqFactory;
    private final AtomFactory atomFactory;
    private final RDF rdfFactory;
    private final FunctionSymbolFactory functionSymbolFactory;

    private static final Logger log = LoggerFactory.getLogger(RDF4JInputQueryTranslatorImpl.class);

    @Inject
    public RDF4JInputQueryTranslatorImpl(CoreUtilsFactory coreUtilsFactory, TermFactory termFactory, SubstitutionFactory substitutionFactory,
                                         TypeFactory typeFactory, IntermediateQueryFactory iqFactory, AtomFactory atomFactory, RDF rdfFactory,
                                         FunctionSymbolFactory functionSymbolFactory) {
        this.coreUtilsFactory = coreUtilsFactory;
        this.termFactory = termFactory;
        this.substitutionFactory = substitutionFactory;
        this.typeFactory = typeFactory;
        this.iqFactory = iqFactory;
        this.atomFactory = atomFactory;
        this.rdfFactory = rdfFactory;
        this.functionSymbolFactory = functionSymbolFactory;
    }

    @Override
    public IQ translate(ParsedQuery pq) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        VariableGenerator variableGenerator = coreUtilsFactory.createVariableGenerator(ImmutableList.of());

        log.debug("Parsed query:\n{}", pq.toString());

        IQTree tree = translate(pq.getTupleExpr(), variableGenerator).iqTree;

        ImmutableSet<Variable> vars = tree.getVariables();

        // Assumption: the binding names in the parsed query are in the desired order
        ImmutableList<Variable> projectedVars = pq.getTupleExpr().getBindingNames().stream()
                .map(termFactory::getVariable)
                // filter out the extra bindings generated by the rdf4j API for constants
                .filter(v -> vars.contains(v))
                .collect(ImmutableCollectors.toList());

        return iqFactory.createIQ(
                atomFactory.getDistinctVariableOnlyDataAtom(
                        atomFactory.getRDFAnswerPredicate(projectedVars.size()),
                        projectedVars
                ),
                tree
        ).normalizeForOptimization();
//        );
    }

    @Override
    public IQ translateAskQuery(ParsedQuery pq) throws OntopUnsupportedInputQueryException, OntopInvalidInputQueryException {

        VariableGenerator variableGenerator = coreUtilsFactory.createVariableGenerator(ImmutableList.of());

        log.debug("Parsed query:\n{}", pq.toString());

        IQTree tree = translate(pq.getTupleExpr(), variableGenerator).iqTree;

        return iqFactory.createIQ(
                atomFactory.getDistinctVariableOnlyDataAtom(
                        atomFactory.getRDFAnswerPredicate(0),
                        ImmutableList.of()
                ),
                projectOutAllVars(tree)
        ).normalizeForOptimization();
    }

    private IQTree projectOutAllVars(IQTree tree) {
        if (tree.getRootNode() instanceof QueryModifierNode) {
            return iqFactory.createUnaryIQTree(
                    (UnaryOperatorNode) tree.getRootNode(),
                    projectOutAllVars(((UnaryIQTree) tree).getChild())
            );
        }
        return iqFactory.createUnaryIQTree(
                iqFactory.createConstructionNode(
                        ImmutableSet.of()
                ),
                tree
        );
    }

    private TranslationResult translate(TupleExpr node, VariableGenerator variableGenerator) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        if (node instanceof StatementPattern)
            return translateTriplePattern((StatementPattern) node);

        if (node instanceof Join)
            return translateJoinLikeNode((Join) node, variableGenerator);

        if (node instanceof LeftJoin)
            return translateJoinLikeNode((LeftJoin) node, variableGenerator);

        if (node instanceof Union)
            return translateUnion((Union) node, variableGenerator);

        if (node instanceof Filter)
            return translateFilter((Filter) node, variableGenerator);

        if (node instanceof Projection)
            return translateProjection((Projection) node, variableGenerator);

        if (node instanceof Slice)
            return translateSlice((Slice) node, variableGenerator);

        if (node instanceof Distinct)
            return translateDistinctOrReduced(node, variableGenerator);

        if (node instanceof Reduced)
            return translateDistinctOrReduced(node, variableGenerator);

        if (node instanceof SingletonSet)
            return translateSingletonSet();

        if (node instanceof Extension)
            return translateExtension((Extension) node, variableGenerator);

        if (node instanceof BindingSetAssignment)
            return translateBindingSetAssignment((BindingSetAssignment) node);

        if (node instanceof Order)
            return translateOrder((Order) node, variableGenerator);

        throw new Sparql2IqConversionException("Unexpected SPARQL operator : " + node.toString());
    }

    private TranslationResult translateOrder(Order node, VariableGenerator variableGenerator) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult child = translate(node.getArg(), variableGenerator);
        ImmutableSet<Variable> variables = child.iqTree.getVariables();
        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        iqFactory.createOrderByNode(
                                node.getElements().stream()
                                        .map(o -> getOrderComparator(o, variables))
                                        .collect(ImmutableCollectors.toList())
                        ),
                        child.iqTree
                ),
                child.nullableVariables
        );
    }

    private OrderByNode.OrderComparator getOrderComparator(OrderElem oe, ImmutableSet<Variable> variables) {
        ImmutableTerm expr = getTerm(oe.getExpr(), variables);
        if (expr.isGround()) {
            throw new RuntimeException(
                    new OntopUnsupportedInputQueryException("The ordering criterion " + oe.getExpr() + "does not contain any variables"));
        }
        return iqFactory.createOrderComparator(
                (NonGroundTerm) expr,
                oe.isAscending()
        );
    }


    private TranslationResult translateBindingSetAssignment(BindingSetAssignment node) {

//        ImmutableSet<Variable> valueVars = node.getBindingNames().stream()
//                .map(termFactory::getVariable)
//                .collect(ImmutableCollectors.toSet());
        ImmutableSet<Variable> valueVars = node.getAssuredBindingNames().stream()
                .map(termFactory::getVariable)
                .collect(ImmutableCollectors.toSet());

        if (containsDuplicateBinding(node)) {
            throw new Sparql2IqConversionException("Unexpected input: two bindings for are associated to the same variable:"
                    + node.getBindingSets().toString());
        }
        ImmutableMap<Variable, ImmutableTerm> map = StreamSupport.stream(node.getBindingSets().spliterator(), false)
                .flatMap(bs -> getBsMap(bs, valueVars).entrySet().stream())
                .collect(ImmutableCollectors.toMap());

        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        iqFactory.createConstructionNode(
                                valueVars,
                                substitutionFactory.getSubstitution(map)),
                        iqFactory.createTrueNode()
                ),
                valueVars
                //             Sets.difference(valueVars, valueVars).immutableCopy()
        );
    }

    private boolean containsDuplicateBinding(BindingSetAssignment node) {
        Set<String> s = new HashSet();
        return StreamSupport.stream(node.getBindingSets().spliterator(), false)
                .flatMap(bs -> bs.getBindingNames().stream())
                .anyMatch(n -> !s.add(n));
    }

    private ImmutableMap<Variable, ImmutableTerm> getBsMap(BindingSet bs, ImmutableSet<Variable> valueVars) {
        return bs.getBindingNames().stream()
                .collect(ImmutableCollectors.toMap(
                        termFactory::getVariable,
                        x -> getTermForBinding(
                                x,
                                bs
                        )));
    }

    private ImmutableTerm getTermForBinding(String x, BindingSet bindingSet) {
        Binding binding = bindingSet.getBinding(x);
        return binding == null
                ? termFactory.getNullConstant()
                : getTermForLiteralOrIri(binding.getValue());
    }

    private TranslationResult translateSingletonSet() {
        return new TranslationResult(
                iqFactory.createTrueNode(),
                ImmutableSet.of()
        );
    }

    private TranslationResult translateDistinctOrReduced(TupleExpr genNode, VariableGenerator variableGenerator) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult child;
        if (genNode instanceof Distinct) {
            child = translate(((Distinct) genNode).getArg(), variableGenerator);
        } else if (genNode instanceof Reduced) {
            child = translate(((Reduced) genNode).getArg(), variableGenerator);
        } else {
            throw new Sparql2IqConversionException("Unexpected node type for node: " + genNode.toString());
        }
        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        iqFactory.createDistinctNode(),
                        child.iqTree
                ),
                child.nullableVariables
        );
    }

    private TranslationResult translateSlice(Slice node, VariableGenerator variableGenerator) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult child = translate(node.getArg(), variableGenerator);

        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        getSliceNode(node),
                        child.iqTree
                ),
                child.nullableVariables
        );
    }

    private SliceNode getSliceNode(Slice node) {
        // Assumption: at least the limit or the offset is not -1 (otherwise the rdf4j parser would not generate a slice node)
        long offset = node.getOffset() == -1 ?
                0 :
                node.getOffset();
        return node.getLimit() == -1 ?
                iqFactory.createSliceNode(offset) :
                iqFactory.createSliceNode(
                        offset,
                        node.getLimit()
                );
    }

    private TranslationResult translateFilter(Filter filter, VariableGenerator variableGenerator)
            throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        TranslationResult child = translate(filter.getArg(), variableGenerator);
        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        iqFactory.createFilterNode(
                                getFilterExpression(
                                        filter.getCondition(),
                                        child.iqTree.getVariables()
                                )),
                        child.iqTree
                ),
                child.nullableVariables
        );
    }

    private TranslationResult translateJoinLikeNode(BinaryTupleOperator join, VariableGenerator variableGenerator) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        if (!(join instanceof Join) && !(join instanceof LeftJoin)) {
            throw new Sparql2IqConversionException("A left or inner join is expected");
        }
        TranslationResult leftTranslation = translate(join.getLeftArg(), variableGenerator);
        TranslationResult rightTranslation = translate(join.getRightArg(), variableGenerator);

        IQTree leftQuery = leftTranslation.iqTree;
        IQTree rightQuery = rightTranslation.iqTree;

        ImmutableSet<Variable> nullableFromLeft = leftTranslation.nullableVariables;
        ImmutableSet<Variable> nullableFromRight = rightTranslation.nullableVariables;

        ImmutableSet<Variable> projectedFromRight = rightTranslation.iqTree.getVariables();
        ImmutableSet<Variable> projectedFromLeft = leftTranslation.iqTree.getVariables();

        ImmutableSet<Variable> toCoalesce = projectedFromLeft.stream()
                .filter(v -> projectedFromRight.contains(v))
                .filter(v -> nullableFromLeft.contains(v) || nullableFromRight.contains(v))
                .collect(ImmutableCollectors.toSet());

        InjectiveVar2VarSubstitution leftRenamingSubstitution = generateVariableSubstitution(
                toCoalesce, variableGenerator);
        InjectiveVar2VarSubstitution rightRenamingSubstitution = generateVariableSubstitution(
                toCoalesce, variableGenerator);

        ImmutableSubstitution<ImmutableTerm> topSubstitution = substitutionFactory.getSubstitution(toCoalesce.stream()
                .collect(ImmutableCollectors.toMap(
                        x -> x,
                        x -> termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getSPARQLFunctionSymbol(SPARQL.COALESCE, 2).get(),
                                leftRenamingSubstitution.get(x),
                                rightRenamingSubstitution.get(x)
                        ))));

        Optional<ImmutableExpression> filterExpression = join instanceof LeftJoin ?
                getLeftJoinFilter(
                        (LeftJoin) join,
                        topSubstitution,
                        Sets.union(
                                projectedFromLeft,
                                projectedFromRight
                        ).immutableCopy()
                ) :
                Optional.empty();


        Optional<ImmutableExpression> joinCondition = generateJoinCondition(
                leftRenamingSubstitution,
                rightRenamingSubstitution,
                toCoalesce,
                filterExpression
        );

        JoinLikeNode joinLikeNode = join instanceof LeftJoin ?
                iqFactory.createLeftJoinNode(joinCondition) :
                iqFactory.createInnerJoinNode(joinCondition);

        ImmutableSet<Variable> sharedVars = Sets.intersection(
                leftQuery.getVariables(),
                rightQuery.getVariables()
        ).immutableCopy();

        ImmutableSet<Variable> nullableVarsUnion = Sets.union(
                nullableFromLeft,
                nullableFromRight
        ).immutableCopy();

        ImmutableSet<Variable> newNullableVars = join instanceof LeftJoin ?
                Sets.difference(
                        rightQuery.getVariables(),
                        sharedVars
                ).immutableCopy() :
                ImmutableSet.of();

        ImmutableSet<Variable> newSetOfNullableVars = join instanceof LeftJoin ?
                Sets.union(
                        nullableVarsUnion,
                        newNullableVars
                ).immutableCopy() :
                Sets.difference(
                        nullableVarsUnion,
                        sharedVars
                ).immutableCopy();


        IQTree joinQuery = buildJoinQuery(
                joinLikeNode,
                leftQuery,
                rightQuery,
                topSubstitution,
                leftRenamingSubstitution,
                rightRenamingSubstitution,
                toCoalesce
        );

        return new TranslationResult(joinQuery, newSetOfNullableVars);
    }

    private Optional<ImmutableExpression> getLeftJoinFilter(LeftJoin join, ImmutableSubstitution<ImmutableTerm> topSubstitution, ImmutableSet<Variable> variables) {
        return join.getCondition() != null ?
                Optional.of(
                        topSubstitution.applyToBooleanExpression(
                                getFilterExpression(
                                        join.getCondition(),
                                        variables
                                ))) :
                Optional.empty();
    }

    private InjectiveVar2VarSubstitution generateVariableSubstitution(
            ImmutableSet<Variable> nullableVariables, VariableGenerator variableGenerator) {

        return substitutionFactory.getInjectiveVar2VarSubstitution(nullableVariables.stream()
                .collect(ImmutableCollectors.toMap(
                        x -> x,
                        variableGenerator::generateNewVariableFromVar
                )));
    }

    private Optional<ImmutableExpression> generateJoinCondition(InjectiveVar2VarSubstitution leftRenamingSubstitution,
                                                                InjectiveVar2VarSubstitution rightRenamingSubstitution,
                                                                ImmutableSet<Variable> toCoalesce,
                                                                Optional<ImmutableExpression> filterCondition) {

        Optional<ImmutableExpression> compatibilityCondition = generateCompatibilityCondition(
                leftRenamingSubstitution,
                rightRenamingSubstitution,
                toCoalesce
        );
        return compatibilityCondition.isPresent() ?
                compatibilityCondition
                        .map(compatExpr -> filterCondition.map(
                                filterExpr -> termFactory.getConjunction(
                                        filterExpr,
                                        compatExpr
                                )).orElse(compatExpr)
                        ) :
                filterCondition;
    }

    private Optional<ImmutableExpression> generateCompatibilityCondition(
            InjectiveVar2VarSubstitution leftChildSubstitution,
            InjectiveVar2VarSubstitution rightChildSubstitution, ImmutableSet<Variable> toCoalesce) {

        return termFactory.getConjunction(toCoalesce.stream()
                .map(v -> generateCompatibleExpression(
                        v,
                        leftChildSubstitution,
                        rightChildSubstitution
                )));
    }

    private ImmutableExpression generateCompatibleExpression(Variable outputVariable,
                                                             InjectiveVar2VarSubstitution leftChildSubstitution,
                                                             InjectiveVar2VarSubstitution rightChildSubstitution) {

        ImmutableExpression isNullExpression;

        Variable leftVariable = leftChildSubstitution.applyToVariable(outputVariable);
        Variable rightVariable = rightChildSubstitution.applyToVariable(outputVariable);

        ImmutableExpression equalityCondition = termFactory.getStrictEquality(leftVariable, rightVariable);
        ImmutableExpression leftIsNull = termFactory.getDBIsNull(leftVariable);
        ImmutableExpression rightIsNull = termFactory.getDBIsNull(rightVariable);
        isNullExpression = termFactory.getDisjunction(leftIsNull, rightIsNull);
        return termFactory.getDisjunction(equalityCondition, isNullExpression);
    }

    private IQTree buildJoinQuery(JoinLikeNode joinNode,
                                  IQTree leftQuery,
                                  IQTree rightQuery,
                                  ImmutableSubstitution<ImmutableTerm> topSubstitution,
                                  InjectiveVar2VarSubstitution leftRenamingSubstitution,
                                  InjectiveVar2VarSubstitution rightRenamingSubstitution,
                                  ImmutableSet<Variable> toCoalesce) {

        ImmutableSet<Variable> projectedVariables = Stream.concat(
                Stream.concat(
                        leftQuery.getVariables().stream(),
                        rightQuery.getVariables().stream()
                ).filter(v -> !toCoalesce.contains(v)),
                topSubstitution.getImmutableMap().keySet().stream())
                .collect(ImmutableCollectors.toSet());

        IQTree joinTree = getJoinTree(
                joinNode,
                leftQuery.applyDescendingSubstitutionWithoutOptimizing(leftRenamingSubstitution),
                rightQuery.applyDescendingSubstitutionWithoutOptimizing(rightRenamingSubstitution)
        );

        return topSubstitution.isEmpty() ?
                joinTree :
                iqFactory.createUnaryIQTree(
                        iqFactory.createConstructionNode(
                                projectedVariables,
                                topSubstitution
                        ),
                        joinTree
                );
    }

    private IQTree getJoinTree(JoinLikeNode joinNode, IQTree leftTree, IQTree rightTree) {
        if (joinNode instanceof LeftJoinNode) {
            return iqFactory.createBinaryNonCommutativeIQTree(
                    (LeftJoinNode) joinNode,
                    leftTree,
                    rightTree
            );
        }
        if (joinNode instanceof InnerJoinNode) {
            return iqFactory.createNaryIQTree(
                    (InnerJoinNode) joinNode,
                    ImmutableList.of(
                            leftTree,
                            rightTree
                    )
            );
        }
        throw new Sparql2IqConversionException("Left or inner join expected");
    }

    private TranslationResult translateProjection(Projection node, VariableGenerator variableGenerator) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult child = translate(node.getArg(), variableGenerator);
        IQTree subQuery = child.iqTree;

        List<ProjectionElem> projectionElems = node.getProjectionElemList().getElements();

        ImmutableSubstitution<Variable> substitution =
                substitutionFactory.getSubstitution(projectionElems.stream()
                        .filter(pe -> !pe.getTargetName().equals(pe.getSourceName()))
                        .collect(ImmutableCollectors.toMap(
                                pe -> termFactory.getVariable(pe.getSourceName()),
                                pe -> termFactory.getVariable(pe.getTargetName())
                        )));

        ImmutableSet<Variable> projectedVars = projectionElems.stream()
                .map(pe -> termFactory.getVariable(pe.getTargetName()))
                .collect(ImmutableCollectors.toSet());

        if (substitution.isEmpty() && projectedVars.equals(child.iqTree.getVariables())) {
            return child;
        }

        subQuery = subQuery.applyDescendingSubstitutionWithoutOptimizing(substitution);
        ConstructionNode projectNode = iqFactory.createConstructionNode(
                projectionElems.stream()
                        .map(pe -> termFactory.getVariable(pe.getTargetName()))
                        .collect(ImmutableCollectors.toSet())
        );
        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        projectNode,
                        subQuery
                ),
                child.nullableVariables.stream()
                        .map(substitution::applyToVariable)
                        .filter(t -> t instanceof Variable)
                        .map(t -> (Variable) t)
                        .collect(ImmutableCollectors.toSet())
        );
    }

    private TranslationResult translateUnion(Union union, VariableGenerator variableGenerator) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult leftTranslation = translate(union.getLeftArg(), variableGenerator);
        TranslationResult rightTranslation = translate(union.getRightArg(), variableGenerator);

        IQTree leftQuery = leftTranslation.iqTree;
        IQTree rightQuery = rightTranslation.iqTree;

        ImmutableSet<Variable> nullableFromLeft = leftTranslation.nullableVariables;
        ImmutableSet<Variable> nullableFromRight = rightTranslation.nullableVariables;

        ImmutableSet<Variable> leftVariables = leftQuery.getVariables();
        ImmutableSet<Variable> rightVariables = rightQuery.getVariables();

        ImmutableSet<Variable> nullOnLeft = Sets.difference(rightVariables, leftVariables).immutableCopy();
        ImmutableSet<Variable> nullOnRight = Sets.difference(leftVariables, rightVariables).immutableCopy();

        ImmutableSet<Variable> allNullable = Sets.union(nullableFromLeft, Sets.union(nullableFromRight, Sets.union(nullOnLeft, nullOnRight))).immutableCopy();

        ImmutableSet<Variable> rootVariables = Sets.union(leftVariables, rightVariables).immutableCopy();

        ImmutableSubstitution<ImmutableTerm> leftSubstitution = substitutionFactory.getSubstitution(nullOnLeft.stream()
                .collect(ImmutableCollectors.toMap(
                        x -> x,
                        x -> termFactory.getNullConstant()
                )));

        ImmutableSubstitution<ImmutableTerm> rightSubstitution = substitutionFactory.getSubstitution(nullOnRight.stream()
                .collect(ImmutableCollectors.toMap(
                        x -> x,
                        x -> termFactory.getNullConstant()
                )));

        ConstructionNode leftCn = iqFactory.createConstructionNode(rootVariables, leftSubstitution);
        ConstructionNode rightCn = iqFactory.createConstructionNode(rootVariables, rightSubstitution);

        UnionNode unionNode = iqFactory.createUnionNode(rootVariables);

        ConstructionNode rootNode = iqFactory.createConstructionNode(rootVariables);

        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        rootNode,
                        iqFactory.createNaryIQTree(
                                unionNode,
                                ImmutableList.of(
                                        iqFactory.createUnaryIQTree(
                                                leftCn,
                                                leftQuery
                                        ),
                                        iqFactory.createUnaryIQTree(
                                                rightCn,
                                                rightQuery
                                        )))),
                allNullable
        );
    }

    private TranslationResult translateTriplePattern(StatementPattern triple) {

        return new TranslationResult(
                iqFactory.createIntensionalDataNode(
                        atomFactory.getIntensionalTripleAtom(
                                translateVar(triple.getSubjectVar()),
                                translateVar(triple.getPredicateVar()),
                                translateVar(triple.getObjectVar())
                        )),
                ImmutableSet.of()
        );
    }

    private TranslationResult translateExtension(Extension node, VariableGenerator variableGenerator) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        TranslationResult childTranslation = translate(node.getArg(), variableGenerator);
        IQTree childQuery = childTranslation.iqTree;
        ImmutableSet<Variable> childNullableVars = childTranslation.nullableVariables;

        // Warning: an ExtensionElement might reference a variable appearing in a previous ExtensionElement
        // So we may need to nest them

        // Assumption: every variable used in a definition is itself defined either in the subtree of in a previous ExtensionElem
        ImmutableList<VarDef> varDefs = ImmutableList.copyOf(
                getVarDefs(
                        node.getElements().iterator(),
                        new HashSet<>(childQuery.getVariables())
                ));

        ImmutableList<ImmutableSubstitution> mergedVarDefs = mergeVarDefs(varDefs.iterator()).stream()
                .map(m -> ImmutableMap.copyOf(m))
                .map(m -> substitutionFactory.getSubstitution(m))
                .collect(ImmutableCollectors.toList());

        return translateExtensionElems(
                mergedVarDefs.reverse().iterator(),
                childTranslation
        );
    }

    private List<VarDef> getVarDefs(Iterator<ExtensionElem> it, Set<Variable> allowedVars) {
        if (it.hasNext()) {
            ExtensionElem elem = it.next();
            if (elem.getExpr() instanceof Var && elem.getName().equals(((Var) elem.getExpr()).getName())) {
                return getVarDefs(it, allowedVars);
            }
            ImmutableTerm term = getTerm(
                    elem.getExpr(),
                    allowedVars
            );
            Variable definedVar = termFactory.getVariable(elem.getName());
            allowedVars.add(definedVar);

            List<VarDef> varDefs = getVarDefs(it, allowedVars);
            varDefs.add(
                    new VarDef(
                            definedVar,
                            term
                    ));
            return varDefs;
        }
        return new ArrayList<>();
    }

    private TranslationResult translateExtensionElems(UnmodifiableIterator<ImmutableSubstitution> it, TranslationResult subquery) {
        if (it.hasNext()) {
            ImmutableSubstitution sub = it.next();
            TranslationResult child = translateExtensionElems(it, subquery);
            ImmutableSet<Variable> newNullableVariables = getNewNullableVars(sub.getImmutableMap(), child.nullableVariables);
            return new TranslationResult(
                    iqFactory.createUnaryIQTree(
                            iqFactory.createConstructionNode(
                                    Sets.union(
                                            child.iqTree.getVariables(),
                                            sub.getDomain()
                                    ).immutableCopy(),
                                    sub
                            ),
                            child.iqTree
                    ),
                    Sets.union(
                            child.nullableVariables,
                            newNullableVariables
                    ).immutableCopy()
            );
        }

        return new TranslationResult(
                subquery.iqTree,
                subquery.nullableVariables
        );
    }

    private ImmutableSet<Variable> getNewNullableVars(ImmutableMap<Variable, ImmutableTerm> sub, ImmutableSet<Variable> nullableVariables) {
        return sub.entrySet().stream()
                .filter(e -> e.getValue().getVariableStream()
                        .anyMatch(v -> nullableVariables.contains(v)))
                .map(e -> e.getKey())
                .collect(ImmutableCollectors.toSet());
    }

    private List<HashMap<Variable, ImmutableTerm>> mergeVarDefs(UnmodifiableIterator<VarDef> it) {
        if (it.hasNext()) {
            VarDef varDef = it.next();
            List<HashMap<Variable, ImmutableTerm>> subs = mergeVarDefs(it);
            HashMap<Variable, ImmutableTerm> currentsub = subs.get(subs.size() - 1);
            if (varDef.term.getVariableStream()
                    .anyMatch(v -> currentsub.containsKey(v))) {
                HashMap<Variable, ImmutableTerm> map = new HashMap<>();
                map.put(varDef.var, varDef.term);
                subs.add(map);
                return subs;
            }
            currentsub.put(
                    varDef.var,
                    varDef.term
            );
            return subs;
        }
        List<HashMap<Variable, ImmutableTerm>> list = new ArrayList<>();
        list.add(new HashMap<>());
        return list;
    }

    private ImmutableTerm getTermForLiteralOrIri(Value v) {

        if (v instanceof Literal) {
            try {
                return getTermForLiteral((Literal) v);
            } catch (OntopUnsupportedInputQueryException e) {
                throw new RuntimeException(e);
            }
        }
        if (v instanceof IRI)
            return getTermForIri((IRI) v);

        throw new RuntimeException(new OntopUnsupportedInputQueryException("The value " + v + " is not supported yet!"));
    }

    private ImmutableTerm getTermForLiteral(Literal literal) throws OntopUnsupportedInputQueryException {
        IRI typeURI = literal.getDatatype();
        String value = literal.getLabel();
        Optional<String> lang = literal.getLanguage();

        if (lang.isPresent()) {
            return termFactory.getRDFLiteralConstant(value, lang.get());

        } else {
            RDFDatatype type;
            /*
             * default data type is xsd:string
             */
            if (typeURI == null) {
                type = typeFactory.getXsdStringDatatype();
            } else {
                type = typeFactory.getDatatype(rdfFactory.createIRI(typeURI.stringValue()));
            }

            if (type == null)
                // ROMAN (27 June 2016): type1 in open-eq-05 test would not be supported in OWL
                // the actual value is LOST here
                return termFactory.getConstantIRI(rdfFactory.createIRI(typeURI.stringValue()));
            // old strict version:
            // throw new RuntimeException("Unsupported datatype: " + typeURI);

            // BC-march-19: it seems that SPARQL does not forbid invalid lexical forms
            //     (e.g. when interpreted as an EBV, they evaluate to false)
            // However, it is unclear in which cases it would be interesting to offer a (partial) robustness to
            // such errors coming from the input query
            // check if the value is (lexically) correct for the specified datatype
            if (!XMLDatatypeUtil.isValidValue(value, typeURI))
                throw new OntopUnsupportedInputQueryException(
                        String.format("Invalid lexical forms are not accepted. Found for %s: %s", type.toString(), value));

            return termFactory.getRDFLiteralConstant(value, type);

        }
    }

    /**
     * @param expr      expression
     * @param variables the set of variables that can occur in the expression
     *                  (the rest will be replaced with NULL)
     */

    private ImmutableExpression getFilterExpression(ValueExpr expr, ImmutableSet<Variable> variables) {

        ImmutableTerm term = getTerm(expr, variables);

        ImmutableTerm xsdBooleanTerm = term.inferType()
                .flatMap(TermTypeInference::getTermType)
                .filter(t -> t instanceof RDFDatatype)
                .filter(t -> ((RDFDatatype) t).isA(XSD.BOOLEAN))
                .isPresent()
                ? term
                : termFactory.getSPARQLEffectiveBooleanValue(term);

        return termFactory.getRDF2DBBooleanFunctionalTerm(xsdBooleanTerm);
    }

    /**
     * @param expr      expression
     * @param variables the set of variables that can occur in the expression
     *                  (the rest will be replaced with NULL)
     * @return term
     */

    private ImmutableTerm getTerm(ValueExpr expr, Set<Variable> variables) {

        // PrimaryExpression ::= BrackettedExpression | BuiltInCall | iriOrFunction |
        //                          RDFLiteral | NumericLiteral | BooleanLiteral | Var
        // iriOrFunction ::= iri ArgList?

        if (expr instanceof Var) {
            return translateVar((Var)expr);
        } else if (expr instanceof ValueConstant) {
            Value v = ((ValueConstant) expr).getValue();
            return getTermForLiteralOrIri(v);
        } else if (expr instanceof Bound) {
            // BOUND (Sec 17.4.1.1)
            // xsd:boolean  BOUND (variable var)
            Var v = ((Bound) expr).getArg();
            Variable var = termFactory.getVariable(v.getName());
            return variables.contains(var) ?
                    termFactory.getImmutableFunctionalTerm(
                            functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                    SPARQL.BOUND,
                                    1
                            ),
                            var
                    ) :
                    termFactory.getRDFLiteralConstant("false", XSD.BOOLEAN);
        } else if (expr instanceof UnaryValueOperator) {
            ImmutableTerm term = getTerm(((UnaryValueOperator) expr).getArg(), variables);

            if (expr instanceof Not) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(XPathFunction.NOT.getIRIString(), 1),
                        convertToXsdBooleanTerm(term));
            } else if (expr instanceof IsNumeric) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.IS_NUMERIC, 1),
                        term);
            } else if (expr instanceof IsLiteral) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.IS_LITERAL, 1),
                        term);
            } else if (expr instanceof IsURI) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.IS_IRI, 1),
                        term);
            } else if (expr instanceof Str) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.STR, 1),
                        term);
            } else if (expr instanceof Datatype) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.DATATYPE, 1),
                        term);
            } else if (expr instanceof IsBNode) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.IS_BLANK, 1),
                        term);
            } else if (expr instanceof Lang) {
                ValueExpr arg = ((UnaryValueOperator) expr).getArg();
                if (arg instanceof Var)
                    return termFactory.getImmutableFunctionalTerm(
                            functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LANG, 1),
                            term);
                throw new RuntimeException(new OntopUnsupportedInputQueryException("A variable or a value is expected in " + expr));
            }
            // other subclasses
            // IRIFunction: IRI (Sec 17.4.2.8) for constructing IRIs
            // IsNumeric:  isNumeric (Sec 17.4.2.4) for checking whether the argument is a numeric value
            // AggregateOperatorBase: Avg, Min, Max, etc.
            // Like:  ??
            // IsResource: ??
            // LocalName: ??
            // Namespace: ??
            // Label: ??
        } else if (expr instanceof BinaryValueOperator) {
            BinaryValueOperator bexpr = (BinaryValueOperator) expr;
            ImmutableTerm term1 = getTerm(bexpr.getLeftArg(), variables);
            ImmutableTerm term2 = getTerm(bexpr.getRightArg(), variables);

            if (expr instanceof And) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LOGICAL_AND, 2),
                        convertToXsdBooleanTerm(term1), convertToXsdBooleanTerm(term2));
            } else if (expr instanceof Or) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LOGICAL_OR, 2),
                        convertToXsdBooleanTerm(term1), convertToXsdBooleanTerm(term2));
            } else if (expr instanceof SameTerm) {
                // sameTerm (Sec 17.4.1.8)
                // Corresponds to the STRICT equality (same lexical value, same type)
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.SAME_TERM, 2),
                        term1, term2);
            } else if (expr instanceof Regex) {
                // REGEX (Sec 17.4.3.14)
                // xsd:boolean  REGEX (string literal text, simple literal pattern)
                // xsd:boolean  REGEX (string literal text, simple literal pattern, simple literal flags)
                Regex reg = (Regex) expr;
                return (reg.getFlagsArg() != null)
                        ? termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.REGEX, 3),
                        term1, term2,
                        getTerm(reg.getFlagsArg(), variables))
                        : termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.REGEX, 2),
                        term1, term2);
            } else if (expr instanceof Compare) {
                final SPARQLFunctionSymbol p;

                switch (((Compare) expr).getOperator()) {
                    case NE:
                        return termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getRequiredSPARQLFunctionSymbol(XPathFunction.NOT.getIRIString(), 1),
                                termFactory.getImmutableFunctionalTerm(
                                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.EQ, 2),
                                        term1, term2));
                    case EQ:
                        p = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.EQ, 2);
                        break;
                    case LT:
                        p = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LESS_THAN, 2);
                        break;
                    case LE:
                        return termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getRequiredSPARQLFunctionSymbol(XPathFunction.NOT.getIRIString(), 1),
                                termFactory.getImmutableFunctionalTerm(
                                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.GREATER_THAN, 2),
                                        term1, term2));
                    case GE:
                        return termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getRequiredSPARQLFunctionSymbol(XPathFunction.NOT.getIRIString(), 1),
                                termFactory.getImmutableFunctionalTerm(
                                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LESS_THAN, 2),
                                        term1, term2));
                    case GT:
                        p = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.GREATER_THAN, 2);
                        break;
                    default:
                        throw new RuntimeException(new OntopUnsupportedInputQueryException("Unsupported operator: " + expr));
                }
                return termFactory.getImmutableFunctionalTerm(p, term1, term2);
            } else if (expr instanceof MathExpr) {
                SPARQLFunctionSymbol f = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                        NumericalOperations.get(((MathExpr) expr).getOperator()), 2);
                return termFactory.getImmutableFunctionalTerm(f, term1, term2);
            }
            /*
             * Restriction: the first argument must be LANG(...) and the second  a constant
             * (for guaranteeing that the langMatches logic is not delegated to the native query)
             */
            else if (expr instanceof LangMatches) {
                if (!(term1 instanceof ImmutableFunctionalTerm
                        && ((ImmutableFunctionalTerm) term1).getFunctionSymbol() instanceof LangSPARQLFunctionSymbol)
                        || !(term2 instanceof RDFConstant)) {
                    throw new RuntimeException(new OntopUnsupportedInputQueryException("The function langMatches is " +
                            "only supported with lang(..) function for the first argument and a constant for the second")
                    );
                }

                SPARQLFunctionSymbol langMatchesFunctionSymbol = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LANG_MATCHES, 2);

                return termFactory.getImmutableFunctionalTerm(langMatchesFunctionSymbol, term1, term2);
            }
        } else if (expr instanceof FunctionCall) {
            FunctionCall f = (FunctionCall) expr;

            ImmutableList<ImmutableTerm> terms = f.getArgs().stream()
                    .map(a -> getTerm(a, variables))
                    .collect(ImmutableCollectors.toList());

            Optional<SPARQLFunctionSymbol> optionalFunctionSymbol = functionSymbolFactory.getSPARQLFunctionSymbol(
                    f.getURI(), terms.size());

            if (optionalFunctionSymbol.isPresent()) {
                return termFactory.getImmutableFunctionalTerm(optionalFunctionSymbol.get(), terms);
            }
        }
        // other subclasses
        // SubQueryValueOperator
        // If
        // BNodeGenerator
        // NAryValueOperator (ListMemberOperator and Coalesce)
        throw new RuntimeException(new OntopUnsupportedInputQueryException("The expression " + expr + " is not supported yet!"));
    }


    /**
     * translates a RDF4J var, which can be a variable or a constant, into a Ontop term.
     *
     * @param var RDF4J var, which can be a variable or a constant
     */
    private VariableOrGroundTerm translateVar(Var var) {
        return (var.hasValue()) ?
                ImmutabilityTools.convertIntoVariableOrGroundTerm(
                        getTermForLiteralOrIri(var.getValue())
                ) :
                getVariable(var);
    }

    private Variable getVariable(Var v) {
        return termFactory.getVariable(v.getName());
    }


    /**
     * @param v URI object
     * @return term (URI template)
     */

    private ImmutableTerm getTermForIri(IRI v) {

        // Guohui(07 Feb, 2018): this logic should probably be moved to a different place, since some percentage-encoded
        // string of an IRI might be a part of an IRI template, but not from database value.
        String uri = R2RMLIRISafeEncoder.decode(v.stringValue());
        //String uri = v.stringValue();
        return termFactory.getConstantIRI(rdfFactory.createIRI(uri));
    }


    private ImmutableTerm convertToXsdBooleanTerm(ImmutableTerm term) {

        return term.inferType()
                .flatMap(TermTypeInference::getTermType)
                .filter(t -> t instanceof RDFDatatype)
                .filter(t -> ((RDFDatatype) t).isA(XSD.BOOLEAN))
                .isPresent() ?
                term :
                termFactory.getSPARQLEffectiveBooleanValue(term);
    }

    private static final ImmutableMap<MathExpr.MathOp, String> NumericalOperations =
            new ImmutableMap.Builder<MathExpr.MathOp, String>()
                    .put(MathExpr.MathOp.PLUS, SPARQL.NUMERIC_ADD)
                    .put(MathExpr.MathOp.MINUS, SPARQL.NUMERIC_SUBSTRACT)
                    .put(MathExpr.MathOp.MULTIPLY, SPARQL.NUMERIC_MULTIPLY)
                    .put(MathExpr.MathOp.DIVIDE, SPARQL.NUMERIC_DIVIDE)
                    .build();

    private static class TranslationResult {
        final IQTree iqTree;
        final ImmutableSet<Variable> nullableVariables;

        TranslationResult(IQTree iqTree, ImmutableSet<Variable> nullableVariables) {
            this.nullableVariables = nullableVariables;
            this.iqTree = iqTree;
        }
    }

    private static class Sparql2IqConversionException extends OntopInternalBugException {

        Sparql2IqConversionException(String s) {
            super(s);
        }
    }

    private class VarDef {
        private final Variable var;
        private final ImmutableTerm term;

        private VarDef(Variable var, ImmutableTerm term) {
            this.var = var;
            this.term = term;
        }
    }
}
